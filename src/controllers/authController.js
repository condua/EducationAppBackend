const User = require("../models/User");
const jwt = require("jsonwebtoken");
const { createCanvas } = require("canvas");
const cloudinary = require("cloudinary").v2;
const bcrypt = require("bcryptjs");
const { OAuth2Client } = require("google-auth-library");
const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);
const sendWelcomeEmail = require("../utils/sendWelcomeEmail");
require("dotenv").config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// T·∫°o Access Token
const generateAccessToken = (user) => {
  return jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, {
    expiresIn: "1h", // Access token th∆∞·ªùng c√≥ th·ªùi gian s·ªëng ng·∫Øn h∆°n (v√≠ d·ª•: 1 gi·ªù)
  });
};

// T·∫°o Refresh Token
const generateRefreshToken = (user) => {
  return jwt.sign(
    { id: user._id, role: user.role },
    process.env.REFRESH_TOKEN_SECRET, // S·ª≠ d·ª•ng secret ri√™ng cho refresh token
    {
      expiresIn: "30d", // Refresh token c√≥ th·ªùi gian s·ªëng d√†i h∆°n (v√≠ d·ª•: 30 ng√†y)
    }
  );
};

function getInitials(name) {
  const words = name.trim().split(" ");
  return words.length >= 2
    ? words[0][0].toUpperCase() + words[words.length - 1][0].toUpperCase()
    : words[0][0].toUpperCase();
}

function getRandomColor(email) {
  let hash = 0;
  for (let i = 0; i < email.length; i++) {
    hash = email.charCodeAt(i) + ((hash << 5) - hash);
  }
  // S·ª≠ d·ª•ng template literal ƒë·ªÉ t·∫°o chu·ªói HSL
  return `hsl(${hash % 360}, 70%, 50%)`;
}

async function generateAvatar(name, email) {
  const initials = getInitials(name);
  const canvas = createCanvas(200, 200);
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = getRandomColor(email);
  ctx.fillRect(0, 0, 200, 200);

  ctx.fillStyle = "#FFFFFF";
  ctx.font = "bold 100px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(initials, 100, 110);

  return canvas.toBuffer();
}

// üü¢ ƒêƒÉng k√Ω t√†i kho·∫£n
exports.register = async (req, res) => {
  try {
    const { fullName, email, password, phone } = req.body;

    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i
    if (await User.findOne({ email })) {
      return res.status(400).json({ message: "Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng" });
    }

    // Ki·ªÉm tra m·∫≠t kh·∫©u h·ª£p l·ªá
    // L∆∞u √Ω: M·∫≠t kh·∫©u c√≥ th·ªÉ kh√¥ng b·∫Øt bu·ªôc n·∫øu b·∫°n cho ph√©p ƒëƒÉng k√Ω qua Google m√† kh√¥ng ƒë·∫∑t m·∫≠t kh·∫©u
    if (!password || password.length < 6) {
      return res
        .status(400)
        .json({ message: "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±" });
    }

    // T·∫°o avatar buffer v√† upload l√™n Cloudinary
    const avatarBuffer = await generateAvatar(fullName, email);
    const uploadResult = await new Promise((resolve, reject) => {
      cloudinary.uploader
        .upload_stream(
          { folder: "avatars", public_id: email.replace(/[@.]/g, "_") },
          (error, result) => (error ? reject(error) : resolve(result))
        )
        .end(avatarBuffer);
    });

    // T·∫°o user m·ªõi (m·∫≠t kh·∫©u s·∫Ω ƒë∆∞·ª£c hash t·ª± ƒë·ªông trong UserSchema)
    const user = new User({
      fullName,
      email,
      password, // M·∫≠t kh·∫©u s·∫Ω ƒë∆∞·ª£c hash b·ªüi pre-save hook trong UserSchema
      phone,
      avatar: uploadResult.secure_url,
    });

    // T·∫°o access token v√† refresh token
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    // L∆∞u refresh token v√†o user
    user.refreshTokens.push(refreshToken);
    await user.save(); // L∆∞u user v·ªõi refresh token

    // ‚úÖ G·ª≠i email ch√†o m·ª´ng
    try {
      await sendWelcomeEmail(email, fullName);
      console.log("ƒê√£ g·ª≠i email ch√†o m·ª´ng");
    } catch (emailErr) {
      console.error("G·ª≠i email th·∫•t b·∫°i:", emailErr.message);
      // C√≥ th·ªÉ b·ªè qua l·ªói n√†y n·∫øu kh√¥ng quan tr·ªçng
    }

    // Tr·∫£ v·ªÅ user (lo·∫°i b·ªè password v√† refreshTokens tr∆∞·ªõc khi g·ª≠i v·ªÅ client)
    const { password: _, refreshTokens: __, ...userResponse } = user._doc;
    res.json({ accessToken, refreshToken, user: userResponse });
  } catch (error) {
    console.error("L·ªói trong qu√° tr√¨nh ƒëƒÉng k√Ω:", error);
    res.status(500).json({ message: "L·ªói server", error });
  }
};

// üü¢ ƒêƒÉng nh·∫≠p
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Ki·ªÉm tra user c√≥ t·ªìn t·∫°i kh√¥ng v√† ch·ªçn tr∆∞·ªùng password
    const user = await User.findOne({ email }).select("+password");
    if (!user)
      return res.status(400).json({ message: "T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i" });

    // Ki·ªÉm tra m·∫≠t kh·∫©u c√≥ t·ªìn t·∫°i kh√¥ng (cho t√†i kho·∫£n ƒëƒÉng k√Ω qua email)
    if (!user.password) {
      return res
        .status(400)
        .json({
          message:
            "T√†i kho·∫£n ch∆∞a thi·∫øt l·∫≠p m·∫≠t kh·∫©u. Vui l√≤ng ƒëƒÉng nh·∫≠p b·∫±ng Google ho·∫∑c ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u.",
        });
    }

    // Ki·ªÉm tra m·∫≠t kh·∫©u c√≥ kh·ªõp kh√¥ng
    const isMatch = await bcrypt.compare(password, user.password);

    if (!isMatch) return res.status(400).json({ message: "Sai m·∫≠t kh·∫©u" });

    // T·∫°o access token v√† refresh token
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    // X√≥a t·∫•t c·∫£ refresh token c≈© v√† th√™m refresh token m·ªõi (cho m·ªói l·∫ßn ƒëƒÉng nh·∫≠p m·ªõi)
    // ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o ch·ªâ c√≥ m·ªôt refresh token h·ª£p l·ªá cho m·ªói phi√™n ƒëƒÉng nh·∫≠p,
    // gi√∫p qu·∫£n l√Ω phi√™n t·ªët h∆°n v√† c√≥ th·ªÉ bu·ªôc ƒëƒÉng xu·∫•t c√°c phi√™n c≈©.
    user.refreshTokens = [refreshToken];
    await user.save();

    // Lo·∫°i b·ªè password v√† refreshTokens khi tr·∫£ v·ªÅ user
    const { password: _, refreshTokens: __, ...userResponse } = user._doc;

    res.json({ accessToken, refreshToken, user: userResponse });
  } catch (error) {
    console.error("L·ªói ƒëƒÉng nh·∫≠p:", error);
    res.status(500).json({ message: "L·ªói server", error });
  }
};

// üü¢ Qu√™n m·∫≠t kh·∫©u (Ch∆∞a tri·ªÉn khai g·ª≠i email)
exports.forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });

    if (!user) return res.status(400).json({ message: "Email kh√¥ng t·ªìn t·∫°i" });

    res.json({ message: "Vui l√≤ng ki·ªÉm tra email ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u" });
  } catch (error) {
    console.error("L·ªói qu√™n m·∫≠t kh·∫©u:", error);
    res.status(500).json({ message: "L·ªói server", error });
  }
};

// üü¢ ƒêƒÉng nh·∫≠p b·∫±ng Google
exports.googleLogin = async (req, res) => {
  const { token } = req.body;

  try {
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const payload = ticket.getPayload();
    const { email, name, picture } = payload;

    let user = await User.findOne({ email });

    if (!user) {
      // üü° N·∫øu Google kh√¥ng c√≥ avatar, t·ª± t·∫°o avatar v·ªõi canvas
      let avatarUrl = picture;
      if (!picture) {
        const avatarBuffer = await generateAvatar(name, email);
        const uploadResult = await new Promise((resolve, reject) => {
          cloudinary.uploader
            .upload_stream(
              { folder: "avatars", public_id: email.replace(/[@.]/g, "_") },
              (error, result) => (error ? reject(error) : resolve(result))
            )
            .end(avatarBuffer);
        });
        avatarUrl = uploadResult.secure_url;
      }

      // T·∫°o m·∫≠t kh·∫©u gi·∫£ ƒë·ªÉ ph√π h·ª£p v·ªõi schema, nh∆∞ng s·∫Ω kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒëƒÉng nh·∫≠p tr·ª±c ti·∫øp
      const fakePassword = Math.random().toString(36).slice(-8);
      const hashedPassword = await bcrypt.hash(fakePassword, 10);

      user = await User.create({
        fullName: name,
        email,
        password: hashedPassword, // M·∫≠t kh·∫©u gi·∫£ ƒë∆∞·ª£c hash
        avatar: avatarUrl,
      });
      // ‚úÖ G·ª≠i email ch√†o m·ª´ng ch·ªâ khi ƒëƒÉng nh·∫≠p l·∫ßn ƒë·∫ßu
      try {
        await sendWelcomeEmail(user.email, user.fullName);
        console.log("ƒê√£ g·ª≠i email ch√†o m·ª´ng");
      } catch (emailErr) {
        console.error("G·ª≠i email th·∫•t b·∫°i:", emailErr.message);
        // C√≥ th·ªÉ b·ªè qua l·ªói n√†y n·∫øu kh√¥ng quan tr·ªçng
      }
    }

    // T·∫°o access token v√† refresh token
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    // X√≥a t·∫•t c·∫£ refresh token c≈© v√† th√™m refresh token m·ªõi cho phi√™n Google Login n√†y
    user.refreshTokens = [refreshToken];
    await user.save(); // L∆∞u user v·ªõi refresh token

    res.status(200).json({
      message: "Login th√†nh c√¥ng",
      user: {
        id: user._id,
        fullName: user.fullName,
        email: user.email,
        avatar: user.avatar,
        role: user.role,
      },
      accessToken,
      refreshToken,
    });
  } catch (err) {
    console.error(err);
    res.status(401).json({ error: "Google token kh√¥ng h·ª£p l·ªá" });
  }
};

// üü¢ C·∫•p l·∫°i Access Token b·∫±ng Refresh Token
exports.requestRefreshToken = async (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    return res.status(401).json({ message: "Kh√¥ng c√≥ refresh token" });
  }

  try {
    // X√°c th·ª±c refresh token
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

    // T√¨m ng∆∞·ªùi d√πng v√† ki·ªÉm tra xem refresh token c√≥ trong danh s√°ch c·ªßa ng∆∞·ªùi d√πng kh√¥ng
    const user = await User.findById(decoded.id);

    if (!user || !user.refreshTokens.includes(refreshToken)) {
      return res
        .status(403)
        .json({ message: "Refresh token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ b·ªã thu h·ªìi" });
    }

    // T·∫°o access token m·ªõi
    const newAccessToken = generateAccessToken(user);

    res.json({ accessToken: newAccessToken });
  } catch (error) {
    console.error("L·ªói refresh token:", error);
    if (error.name === "TokenExpiredError") {
      return res
        .status(403)
        .json({ message: "Refresh token ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i." });
    }
    res.status(403).json({ message: "Refresh token kh√¥ng h·ª£p l·ªá" });
  }
};

// üü¢ ƒêƒÉng xu·∫•t (X√≥a refresh token kh·ªèi DB)
exports.logout = async (req, res) => {
  const { refreshToken } = req.body; // Client g·ª≠i refresh token mu·ªën x√≥a

  if (!refreshToken) {
    return res
      .status(400)
      .json({ message: "Kh√¥ng c√≥ refresh token ƒë·ªÉ ƒëƒÉng xu·∫•t" });
  }

  try {
    // X√°c th·ª±c refresh token ƒë·ªÉ t√¨m ng∆∞·ªùi d√πng
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
    const user = await User.findById(decoded.id);

    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }

    // L·ªçc b·ªè refresh token c·ª• th·ªÉ kh·ªèi m·∫£ng c·ªßa ng∆∞·ªùi d√πng
    user.refreshTokens = user.refreshTokens.filter(
      (token) => token !== refreshToken
    );
    await user.save(); // L∆∞u thay ƒë·ªïi v√†o c∆° s·ªü d·ªØ li·ªáu

    res.status(200).json({ message: "ƒêƒÉng xu·∫•t th√†nh c√¥ng" });
  } catch (error) {
    console.error("L·ªói ƒëƒÉng xu·∫•t:", error);
    if (error.name === "TokenExpiredError") {
      return res
        .status(403)
        .json({
          message: "Refresh token ƒë√£ h·∫øt h·∫°n, kh√¥ng c·∫ßn ƒëƒÉng xu·∫•t th√™m",
        });
    }
    res.status(500).json({ message: "L·ªói server khi ƒëƒÉng xu·∫•t" });
  }
};
